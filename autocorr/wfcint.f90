!=========================================================================
! Performs the integral of wrrp.x output data with a Gaussian cube wavefunction
! generated by Quantum ESPRESSO. 
! Initial version: Keian Noori 09/10/2018. 
!=========================================================================

#include "f_defs.h"

program wfcint

  use params_m
!  use interp_m
  use input_m
  use supercell_m
  use interp_m
  implicit none

!------------------------------------------------------------------------------
  ! Variable declarations
  character :: wfnfile*32,calctype*12,date*8, time*10
  integer :: nat,iat,ngrid(3),nfft(6),sc_size(3),allocerr,ioerr,i,j,k,ir,irp
  real(DP) :: vel,alat !straina(3)
  real(DP) ::dela(3,3),delawrrp(3,3),awfn(3,3),awrrp(3,3),auc(3,3),asc(3,3)
  real(DP) :: centreuc(3), centresc(3), shift(3)
  complex(DPC) :: tmpdata,pol_int
  !character, allocatable :: atomtype(:)
  character, allocatable :: atomtype*2(:)
  integer, allocatable :: rmapwfn(:,:),rmapwrrp(:,:), nn(:,:,:)
  real(DP), allocatable :: datawfn(:),atompos(:,:),bader(:)
  real(DP), allocatable :: rgridwfn(:,:),rgridwrrp(:,:)
  complex(DPC), allocatable :: datawrrp(:,:,:,:,:,:),data3d(:,:,:),datainterp(:,:)
  ! For LAPACK diagonalization Ax=b
!  integer :: n,nrhs,lda,ipiv,ldb,info
  real(DP) :: a(3,3)
  real(DP), allocatable :: b(:,:)
!  !real(DP) :: a(3,5),ratom(4)

!------------------------------------------------------------------------------
  !KN: Test QE wfn cube read with hard-coded filename
  !wfnfile = "wfc.k1.n15.cube"
  !wfnfile = trim(wfnfile)

  write(6,*) repeat("=",79)
  call date_and_time(DATE=date,TIME=time)
  write(6,*) "wfcint.x -- A(nother) simple little program..."
  write(6,*) "version: beta"
  write(6,*) "start time: ",date," at ",time
#ifdef CPLX
  write(6,*) "We are running in COMPLEX mode."
#else 
  write(6,*) "We are running in REAL mode."
#endif 
  write(6,*) repeat("=",79)

!------------------------------------------------------------------------------
! Read "wfcint.inp" input file
  write(6,*) "Reading input file..."
  call read_input_wfcint(nat,atomtype,atompos,bader)
  write(6,'(1x,5a,13a,13a,13a,11a)') "Atom ","x ","y ","z ","Bader"
  do iat = 1,nat 
    write(6,'(1x,a,3f12.6,f10.6)') atomtype(iat),atompos(:,iat),bader(iat)
  enddo
  write(6,*) repeat("=",79)

!------------------------------------------------------------------------------
! QE wavefunction info
! KN: Not used for now
!  write(6,*) "Reading information from QE wavefunction file..." 
!  ! Read wfn cube file data
!  call read_cube(wfnfile,ngrid,dela,atomtype,atompos,datawfn)
!
!  ! Compute the voxel volume 
!  vel = norm2(dela(:,1)) * norm2(dela(:,2)) * norm2(dela(:,3))
!
!  ! Compute the lattice vectors from the wfn cube file
!  awfn(:,1) = ngrid(1) * dela(:,1)
!  awfn(:,2) = ngrid(2) * dela(:,2)
!  awfn(:,3) = ngrid(3) * dela(:,3)
!  
!  write(6,*) "There are ",size(atomtype),"atoms"
!!  write(6,*) "The size of atompos is ",size(atompos),"."
!  write(6,'(1x,a,f10.6)') "The voxel volume (bohr^3) is ",vel
!  write(6,'(1x,a,i12)') "The number of voxels is ",size(datawfn)
!  write(6,'(1x,a,3i5)') "The number of grid pts along a1, a2, and a3 is ",ngrid
!  write(6,*) "The lattice vectors (bohr) are:"
!  write(6,'(3f12.6)') awfn
!  write(6,*) repeat("=",79)

!------------------------------------------------------------------------------
! wrrp.x data file
  write(6,*) "Reading information from wrrp.x output file..."
  call read_wrrp(calctype,alat,awrrp,nfft,sc_size,datawrrp)
  write(6,*) "Data is from a wrrp.x ",calctype,"calculation."
  write(6,'(1x,a,6i4)') "The FFT grid size is ",nfft
  ! Compute unit cell lattice vectors
  auc = alat * awrrp
  write(6,*) "The unit cell lattice vectors (bohr) are:"
  write(6,'(3f12.6)') auc
  ! Compute supercell lattice vectors
  asc(:,1) = sc_size(1) * auc(:,1)
  asc(:,2) = sc_size(2) * auc(:,2)
  asc(:,3) = sc_size(3) * auc(:,3)
  write(6,'(1x,a,3i5)') "The supercell size is ",sc_size
  write(6,*) "The supercell lattice vectors (bohr) are:"
  write(6,'(3f12.6)') asc

!  ! Compute the strain of the wrrp.x lattice vectors wrt to QE wfn vectors
!  straina(1) = (norm2(asc(:,1))-norm2(awfn(:,1)))/norm2(asc(:,1))
!  straina(2) = (norm2(asc(:,2))-norm2(awfn(:,2)))/norm2(asc(:,2))
!  straina(3) = (norm2(asc(:,3))-norm2(awfn(:,3)))/norm2(asc(:,3))
!  write(6,*) "The strain on the wrrp.x supercell lattice vectors is:"
!  write(6,'(1x,a,f10.4,a)') "a1: ",straina(1)*100,"%"
!  write(6,'(1x,a,f10.4,a)') "a2: ",straina(2)*100,"%"
!  write(6,'(1x,a,f10.4,a)') "a3: ",straina(3)*100,"%"
!  write(6,*) repeat("=",79)

!  ! In wrrp.x the centre of the unit cell is shifted to the centre of the
!  ! supercell. Compute that shift in order to properly locate the atoms in the
!  ! supercell.
!  centreuc(:) = 0.5*auc(:,1) + 0.5*auc(:,2) + 0.5*(auc(:,3)) 
!  centresc(:) = 0.5*asc(:,1) + 0.5*asc(:,2) + 0.5*(asc(:,3)) 
!  shift = centresc - centreuc
!  write(6,*) "centre UC"
!  write(6,*) centreuc
!  write(6,*) "centre SC"
!  write(6,*) centresc
!  write(6,*) "shift",shift
!------------------------------------------------------------------------------

  ! Compute the real-space grid points for both the QE wfn and (scaled) wrrp.x
  ! data
  write(6,*) "Computing grid points for wrrp.x data..."
  allocate(rgridwfn(3,product(ngrid)),stat=allocerr)
  allocate(rgridwrrp(3,product(sc_size)*product(nfft)),stat=allocerr)
  allocate(rmapwfn(3,product(ngrid)),stat=allocerr)
  allocate(rmapwrrp(3,product(sc_size)*product(nfft)),stat=allocerr)
  
  ! Log file for grid points
  open(90,file="wfcint.log",form='formatted',status='replace',iostat=ioerr)

!  ! Grid points for QE wfn file
!  write(90,*) "Grid points for wavefunction file in bohr:"
!  ir = 1
!  do i = 1,ngrid(1)
!    do j = 1,ngrid(2)
!      do k = 1,ngrid(3)
!          ! The first grid point in each direction is 0
!          rgridwfn(:,ir) = (i-1)*dela(:,1) + (j-1)*dela(:,2) + (k-1)*dela(:,3)
!          rmapwfn(1,ir) = i
!          rmapwfn(2,ir) = j
!          rmapwfn(3,ir) = k
!          write(90,'(i10,3f10.6,3i5)') ir, rgridwfn(:,ir), rmapwfn(:,ir) 
!          ir = ir + 1
!      enddo
!    enddo
!  enddo
!  write(90,*) repeat("=",79)

  ! Grid points for wrrp.x data
  write(90,*) "Grid points for wrrp.x data file in bohr:"
  !delawrrp(:,1) = asc(:,1) / (sc_size(1)*nfft(1))
  !delawrrp(:,2) = asc(:,2) / (sc_size(2)*nfft(2))
  !delawrrp(:,3) = asc(:,3) / (sc_size(3)*nfft(3))
  delawrrp(:,1) = auc(:,1) / nfft(1)
  delawrrp(:,2) = auc(:,2) / nfft(2)
  delawrrp(:,3) = auc(:,3) / nfft(3)
  ir = 1
  do i = 1,sc_size(1)*nfft(1)
    do j = 1,sc_size(2)*nfft(2)
      do k = 1,sc_size(3)*nfft(3)
          ! The first grid point in each direction is 0
          rgridwrrp(:,ir) = (i-1)*delawrrp(:,1) + (j-1)*delawrrp(:,2) + (k-1)*delawrrp(:,3)
          rmapwrrp(1,ir) = i
          rmapwrrp(2,ir) = j
          rmapwrrp(3,ir) = k
          write(90,'(i10,3f10.6,3i5)') ir, rgridwrrp(:,ir), rmapwrrp(:,ir)
          ir = ir + 1
      enddo
    enddo
  enddo
  write(6,*) repeat("=",79)

!-------------------------------------------------------------------------------- 

  ! Find nearest neighbours
  ! Use DGESV to solve system of equations Ax = b, where the columns of A are
  ! the lattice vectors and the columns of b are the atomic coordinates.
  ! KN: Note that DGESV has dimensions A[n,n] and b[n,natoms], where, in
  ! Fortran, the first index is for columns and the second for rows. We must
  ! therefore input the data as row vectors, i.e. each lattice vector/atomic
  ! coordinate corresponds to a row in its respective matrix.
  write(6,*) "Finding nearest wrrp.x grid points to each atom..."
  allocate(nn(3,8,nat),stat=allocerr)
  allocate(b(3,nat),stat=allocerr)
  ! We copy delawrrp to a() and atompos to b() (for Ax=b) since these matrices are overwritten in the DGESV routin
  a = delawrrp
  b = atompos

!write(6,*) "-----OUTSIDE-----"
!write(6,*) "a is:"
!write(6,*) delawrrp

  call nearest_neighbours(a,b,nn)

  ! Perform the 6D linear interpolation for each r,r' combination
  write(6,*) "Peforming 6D interpolation..."
  allocate(datainterp(nat,nat),stat=allocerr)
!write(6,'(a,3f6.3)') "r is ",atompos(:,1)
!write(6,'(a,3f6.3)') "r' is ",atompos(:,1)

  do ir = 1,nat
    do irp = 1,nat
write(6,*) "=========="
write(6,*) "ir/irp: ",ir,irp 
      call interp6d(datawrrp,delawrrp,atompos(:,ir),atompos(:,irp),nn(:,:,ir),nn(:,:,irp),tmpdata)
      datainterp(ir,irp) = tmpdata
    enddo
  enddo

!-------------------------------------------------------------------------------- 
! Compute polarization integral
  write(6,*) repeat("=",79)
  write(6,*) "Computing polarization integral..."
  pol_int = 0.d0
  do ir = 1,nat
    do irp = 1,nat
     ! if (ir .ne. irp) then
write(6,*) bader(ir)
write(6,*) bader(irp)
write(6,*) datainterp(ir,irp)
      pol_int = pol_int + bader(ir)*bader(irp)*datainterp(ir,irp) 
     ! endif
    enddo
  enddo
  pol_int = -0.5 * pol_int

  write(6,*) "Polarization integral is ",pol_int
  write(6,*) "Finished!"

!-------------------------------------------------------------------------------- 
! Clean up

  close(90)
!  deallocate(atomtype)
!  deallocate(atompos)
!  deallocate(bader)
  deallocate(b)
  deallocate(nn)
  deallocate(datainterp)
  deallocate(rgridwfn)
  deallocate(rgridwrrp)
  deallocate(rmapwfn)
  deallocate(rmapwrrp)

end program wfcint
